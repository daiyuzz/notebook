# 面向对象高级编程

## 使用`__slots__`


正常情况下,当我们定义了一个class,创建了一个class的实例后,我们可以给该实例绑定任何属性和方法,这就是动态语言的灵活性.先定义class:

```python
class Student(object):
    pass
```
然后,尝试给实例绑定一个属性:
```python
s = Student()
s.name = 'Michael'
print(s.name)
Michael
```
还可以尝试给实例绑定一个方法:
```python
def set_age(self,age):
    self.age = age

from types import MethodType
s.set_age = MethodType(set_age,s)
s.set_age(25)
s.age
#25

```
但是,给一个实例绑定的方法,对另一个实例是不起作用的:

```python
s2 = Student()
s2.set_age(25)

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'set_age'
```

为了给所有实例都绑定方法,可以给class绑定方法:
```python
def set_score(self,score):
    self.score = score

...
...
Student.set_score = set_score
```

给class绑定方法后,所有实例均可调用:
```python
s.set_score(100)
s.score
100
s2.set_score(99)
s2.score
99
```

通常情况下,上面的`set_score`方法可以直接定义在class中,但动态绑定允许我们在程序运行的过程中动态的给class加上功能,这在静态语言中很难实现.

### 使用`__slots__`
但是,如果我们需要限制实例的属性怎么办?比如,只允许对Student实例添加`name`和`age`属性.
为了达到限制的目的,Python允许在定义class的时候,定义一个特殊的`__slots__`变量,来限制该class实例能添加的属性:

```python
class Student(Object):
    __slots__ = ('name','age') #用tuple定义允许绑定的属性名称
```

然后我们试试:
```python
s = Student()
s.name = 'Michael'
s.age = 24
s.score = 99
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'

```
由于`score`没有被放到`__slots__`中,所以不能绑定`score`属性,试图绑定`score`将得到`AttributeError`的错误.
使用`__slots__`要注意,`__slots__`定义的属性仅对当前类的实例起作用,对继承的子类是不起作用的:

```python
class GraduateStudent(Student):
    pass

g = GraduateStudent()
g.score = 999

```
除非在子类中也定义`__slots__`,这样,子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__`.


## 使用@property

在绑定属性时,如果我们直接把属性暴露出去,虽然写起来很简单,但是,没办法检查参数,导致可以把成绩随便改:
```python
s = Student()
s.score = 999
```
这样显然不合逻辑.为了限制score的范围,可以通过一个`set_score`方法来设置成绩,再通过一个`get_score()`来获取成绩,这样,在`set_score()`方法里面,就可以检查参数:

```python
class Student(object):
    def get_score(self):
        return self._score
    def set_score(self,value):
        if not isinstance(value,int):
            raise ValueError('score must be an integer!')
        if value <0 or value > 100:
            raise ValueError('some must between 1~100!')
        self._score = value
```

现在,对任意的Student实例进行操作,就不能随心所欲地设置score了


但上面的调用方法又略显复杂,没有直接使用属性这么直接简单.

有没有既能检查参数,又可以用类似属性这样简单的方式来访问类的变量呢?

还记得装饰器(decorator)可以给函数动态的加上功能吗?对于类的方法,装饰器一样起作用. 
python内置的`@property`装饰器就是负责把一个方法变成属性调用的:

```python
class Student(object):
    @property
    def score(self):
        return self._score
    
    @score.setter
    def socre(self,value):
        if not isinstance(value,int):
            raise ValueError("score must be an integer!")
        if value <0 or value > 100:
            self._score = value
```
`@property`的实现比较复杂,我们先考察如何使用,把一个getter方法变成属性,只需要加上`@property`就可以了,此时,`@property`本身创建了另一个装饰器`@score.setter`,负责把一个setter方法变成属性赋值,于是,我们就拥有一个可控制的属性操作:

```python
s = Student()
s.score = 10
s.score
#10
s.score=999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!

```

注意到这个神奇的`@property`,我们在对实例属性操作的时候,就知道该属性很可能不是直接暴露的,而是通过getter, setter实现的.

还可以定义只读属性,只定义getter方法,不定义setter方法就是一个只读属性:

```python
class Student(object):
    @property
    def birth(self):
        return self._birth
    @birth.setter
    def birth(self,value):
        self._birth = value
    @property
    def age(self):
        return 2015-self.birth
```
上面的`birth`是可读写属性,而`age`就是一个只读属性

**小结**
`@property`广泛的应用在类的定义中,可以让调用者写出简短的代码,同时保证对参数进行必要的检查,这样,程序运行时就减少出错的可能性.



## 多重继承
继承是面向对象编程的一个重要的方式,因为通过继承,子类就可以扩展父类的功能.


### MixIn
在设计类的继承关系时，通常，主线都是单一继承下来的，例如，`Ostrich`继承自`Bird`。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让`Ostrich`除了继承自Bird外，再同时继承`Runnable`。这种设计通常称之为`MixIn`。

为了更好地看出继承关系，我们把`Runnable`和`Flyable`改为`RunnableMixIn`和`FlyableMixIn`。类似的，你还可以定义出肉食动物`CarnivorousMixIn`和植食动物`HerbivoresMixIn`，让某个动物同时拥有好几个`MixIn`：

```python
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass

```
``MixIn`的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。

Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。



**小结**
由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。

只允许单一继承的语言（如Java）不能使用MixIn的设计。


## 定制类
看到类似`__slots__`这种形如`__xxx___`的变量和函数名就要注意了,这些在Python中是有特殊用途的.

`__slots__`我们已经知道怎么用了,`__len__()`方法我们也知道是为了让class作用于`len()`函数.除此之外,python的class中还有很多这样有特殊用途的函数,可以帮助我们定制类.

### `__str__`
我们先定义一个`Student`类,打印一个实例:
```python
class Student(Object):
    def __init__(self,name):
        self.name = name
print(Student('Michael'))
# <__main__.Student object at 0x109afb190>
```
打印出一堆`<__main__.Student object at 0x109afb190>`,不好看.

怎么才能打印好看呢?只需要定义好`__str__()`方法,返回一个好看的字符串就可以了:

```python
>>> class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
>>> print(Student('Michael'))
Student object (name: Michael)
```
这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。

但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：

```python
>>> s = Student('Michael')
>>> s
<__main__.Student object at 0x109afb310>
```
这是因为直接显示变量调用的不是`__str__()`，而是`__repr__()`，两者的区别是`__str__()`返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。

解决办法是再定义一个`__repr__()`。但是通常`__str__()`和`__repr__()`代码都是一样的，所以，有个偷懒的写法：
```python
class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__

```

### `__iter__`
如果一个类想被用于`for ... in`循环，类似`list`或`tuple`那样，就必须实现一个`__iter__()`方法，该方法返回一个迭代对象，然后，`Python`的`for`循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到`StopIteration`错误时退出循环。

我们以斐波那契数列为例，写一个Fib类，可以作用于for循环

```python
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
```

```python
>>> for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025

```

### `__getitem__`

Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：

```python
>>> Fib()[5]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'Fib' object does not support indexing
```

要表现得像list那样按照下标取出元素，需要实现`__getitem__()`方法：

```python
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

```
现在，就可以按下标访问数列的任意一项了：

```python
>>> f = Fib()
>>> f[0]
1
>>> f[1]
1
>>> f[2]
2
>>> f[3]
3
>>> f[10]
89
>>> f[100]
573147844013817084101

```

但是list有个神奇的切片方法：


```python
>>> list(range(100))[5:10]
[5, 6, 7, 8, 9]
```

对于Fib却报错。原因是`__getitem__()`传入的参数可能是一个`int`，也可能是一个切片对象`slice`，所以要做判断：

```python
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L

```
现在试试Fib的切片：

```python
>>> f = Fib()
>>> f[0:5]
[1, 1, 2, 3, 5]
>>> f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

```
但是没有对step参数作处理：

```python
>>> f[:10:2]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

```
也没有对负数作处理，所以，要正确实现一个`__getitem__()`还是有很多工作要做的。

此外，如果把对象看成`dict`，`__getitem__()`的参数也可能是一个可以作`key`的`object`，例如`str`。

与之对应的是`__setitem__()`方法，把对象视作`list`或`dict`来对集合赋值。最后，还有一个`__delitem__()`方法，用于删除某个元素。

总之，通过上面的方法，我们自己定义的类表现得和Python自带的`list`、`tuple`、`dict`没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。


### `__getattr__`

正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：

```python
class Student(object):
    
    def __init__(self):
        self.name = 'Michael'

```
调用name属性，没问题，但是，调用不存在的score属性，就有问题了：

```python
>>> s = Student()
>>> print(s.name)
Michael
>>> print(s.score)
Traceback (most recent call last):
  ...
AttributeError: 'Student' object has no attribute 'score'

```

错误信息很清楚地告诉我们，没有找到score这个attribute。

要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个`__getattr__()`方法，动态返回一个属性。修改如下：

```Python
class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99

```

当调用不存在的属性时，比如`score`，`Python`解释器会试图调用`__getattr__(self, 'score')`来尝试获得属性，这样，我们就有机会返回`score`的值：

```python
>>> s = Student()
>>> s.name
'Michael'
>>> s.score
99
```

返回函数也是完全可以的：
```python
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25

```
只是调用方式要变为：
```Python
>>> s.age()
25
```

注意，只有在没有找到属性的情况下，才调用`__getattr__`，已有的属性，比如name，不会在`__getattr__`中查找。


此外，注意到任意调用如`s.abc`都会返回`None`，这是因为我们定义的`__getattr__`默认返回就是`None`。要让`class`只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：

```python
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)

```

这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。

这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。

举个例子：

现在很多网站都搞`REST API`，比如新浪微博、豆瓣啥的，调用API的URL类似：

```
http://api.server/user/friends
http://api.server/user/timeline/list
```
如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。

利用完全动态的`__getattr__`，我们可以写出一个链式调用：

```python
class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__

```
试试:
```
>>> Chain().status.user.timeline.list
'/status/user/timeline/list'

```
这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！

还有些REST API会把参数放到URL中，比如GitHub的API：
```
GET /users/:user/repos
```
调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：

```p
Chain().users('michael').repos
```
就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。


### `__call__`

一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用`instance.method()`来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。

任何类，只需要定义一个`__call__()`方法，就可以直接对实例进行调用。请看示例：

```p
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)

```
调用方式如下:
```p
>>> s = Student('Michael')
>>> s() # self参数不要传入
My name is Michael.

```

`__call__()`还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。

如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。

那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个`Callable`对象，比如函数和我们上面定义的带有`__call__()`的类.

```p
>>> callable(Student())
True
>>> callable(max)
True
>>> callable([1, 2, 3])
False
>>> callable(None)
False
>>> callable('str')
False
```

通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。


**小结**
Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。

## 使用枚举
当我们需要定义常量时,一个办法是用大写变量通过整数来定义,例如月份:

```python
JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12

```
好处是简单,缺点是类型是`int`,并且仍然是变量.

更好的方法是为这样的枚举类型定义一个class类型,然后,每个常量都是class的一个唯一实例.Python提供了`Enum`类来实现这个功能:

```python
from enum import Enum
Month = Enum('Month',('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'))
```
这样我们就获得了`Month`类型的枚举类,可以直接使用`Month.Jan`来引用一个常量,或者枚举它的所有成员:
```python
for name,member in Month.__members__.items():
    print(name,'=>',member,'.',member.value)
```
`value`属性则是自动赋给成员的`int`常量,默认从`1`开始计数.

如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：

```python
from enum import Enum,unique

@unique
class Weekday(Enum):
    Sun = 0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
```
`@unique`装饰器可以帮助我们检查保证没有重复的值.

访问这些枚举类型可以有若干种方法:

```python
>>> day1 = Weekday.Mon
>>> print(day1)
Weekday.Mon
>>> print(Weekday.Tue)
Weekday.Tue
>>> print(Weekday['Tue'])
Weekday.Tue
>>> print(Weekday.Tue.value)
2
>>> print(day1 == Weekday.Mon)
True
>>> print(day1 == Weekday.Tue)
False
>>> print(Weekday(1))
Weekday.Mon
>>> print(day1 == Weekday(1))
True
>>> Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday
>>> for name, member in Weekday.__members__.items():
...     print(name, '=>', member)
...
Sun => Weekday.Sun
Mon => Weekday.Mon
Tue => Weekday.Tue
Wed => Weekday.Wed
Thu => Weekday.Thu
Fri => Weekday.Fri
Sat => Weekday.Sat

```
可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。

**小结**
Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。