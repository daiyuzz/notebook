vnote_backup_file_826537664 /home/daiyu/notebook/数据分析/NumPy基础.md
# NumPy基础：数组和矢量计算
NumPy（Numerical Python的简称）是python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建的基础。

NumPy的部分功能如下：
- ndarray，一个具有矢量运算和复杂广播能力的快速且节省空间的多维数组。
- 用于对整组数据进行快速运算的标准数学函数（无需编写循环）
- 用于读写磁盘的数据的工具以及用于操作内存映射文件的工具。
- 线性代数、随机数生成以及傅里叶变换功能。
- 用于集成由c、c++、Fortran等语言编写的代码的 A C API。

对于大部分数据分析应用而言，我最关注的功能主要集中在：
- 用于数据整理和清洗、子集构造和过滤、转换等快速的矢量化数组运算
- 常用的数组算法，如排序、唯一化、集合运算等。
- 高效的描述统计和数据聚合/链接运算的数据对齐和关系型数据的运算
- 将条件逻辑表述为数组表达式
- 数据的分组运算（聚合、转换、函数应用等）


## NumPy的ndarray：一种多维数组对象
NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。

### 创建ndarray
创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组

如：
```python
In [19]: data1 = [6, 7.5, 8, 0, 1]

In [20]: arr1 = np.array(data1)

In [21]: arr1
Out[21]: array([ 6. ,  7.5,  8. ,  0. ,  1. ])
```
```python
In [22]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]

In [23]: arr2 = np.array(data2)

In [24]: arr2
Out[24]: 
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
```

除了`np.array`之外，还有一些函数也可以新建数组，比如，`zeros`和`ones`分别可以创建指定长度或形状的全0或全1数组。`empty`还可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需要传入一个表示形状的元祖即可：
```python
In [29]: np.zeros(10)
Out[29]: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])

In [30]: np.zeros((3, 6))
Out[30]: 
array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])

In [31]: np.empty((2, 3, 2))
Out[31]: 
array([[[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]],
       [[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]]])
```

注意：认为`np.empty`会返回全0数组的想法是不安全的。很多情况下，它返回的都是一些未初始化的垃圾值。

arange是python内置函数range的数组版：
```python
In [32]: np.arange(15)
Out[32]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
```
![](assets/20191009195501407_2002246733.png)

### ndarray的数据类型
dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：

```python
In [33]: arr1 = np.array([1, 2, 3], dtype=np.float64)

In [34]: arr2 = np.array([1, 2, 3], dtype=np.int32)

In [35]: arr1.dtype
Out[35]: dtype('float64')

In [36]: arr2.dtype
Out[36]: dtype('int32')
```
![](assets/20191009195834117_1644841078.png)

可以通过ndarray的astype方法明确地将一个数组从dtype转换成另一个dtype：
```python
In [37]: arr = np.array([1, 2, 3, 4, 5])

In [38]: arr.dtype
Out[38]: dtype('int64')

In [39]: float_arr = arr.astype(np.float64)

In [40]: float_arr.dtype
Out[40]: dtype('float64')

```

如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：
```python
In [44]: numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)

In [45]: numeric_strings.astype(float)
Out[45]: array([  1.25,  -9.6 ,  42.  ])
```
注意：使用`numpy.string_`类型时，一定要小心，因为NunPy的字符创数据是大小固定的，发生截取时，不会发生警告。pandas提供了更多非数值数据的便利处理方法。

笔记：调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。

### NumPy数组的运算
数组很重要，因为它使你不用编写循环即可对数据执行批量运算。Numpy用户称其为矢量化（vectorization）。

大小相等的数组之间的任何算数运算都将运算应用到元素级：

```python
In [51]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])

In [52]: arr
Out[52]: 
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])

In [53]: arr * arr
Out[53]: 
array([[  1.,   4.,   9.],
       [ 16.,  25.,  36.]])

In [54]: arr - arr
Out[54]: 
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
```
数组与标量的算数运算会将标量值传播到各个元素：
```python
In [55]: 1 / arr
Out[55]: 
array([[ 1.    ,  0.5   ,  0.3333],
       [ 0.25  ,  0.2   ,  0.1667]])

In [56]: arr ** 0.5
Out[56]: 
array([[ 1.    ,  1.4142,  1.7321],
       [ 2.    ,  2.2361,  2.4495]])

```
大小相同的数组之间的比较会产生布尔值数组

```python
In [57]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])

In [58]: arr2
Out[58]: 
array([[  0.,   4.,   1.],
       [  7.,   2.,  12.]])

In [59]: arr2 > arr
Out[59]:
array([[False,  True, False],
       [ True, False,  True]], dtype=bool)
```
不同大小的数组之间的运算叫做广播(broadcasting)

### 基本的索引和切片
Numpy数组的索引是一个内容丰富的主题。

一维数组很简单，从表面上看，他们跟python列表的功能差不多：

```python
In [60]: arr = np.arange(10)

In [61]: arr
Out[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [62]: arr[5]
Out[62]: 5

In [63]: arr[5:8]
Out[63]: array([5, 6, 7])

In [64]: arr[5:8] = 12

In [65]: arr
Out[65]: array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
```
数组切片是原始数组的视图，这意味着数据不会被复制，视图上的任何修改都会直接反应到源数组上。

作为例子，先创建一个arr的切片
```python
In [66]: arr_slice = arr[5:8]

In [67]: arr_slice
Out[67]: array([12, 12, 12])

```
现在，当我们修改arr_slice的值，变动也会体现在原始数组arr中：
```python
In [68]: arr_slice[1] = 12345

In [69]: arr
Out[69]: array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,   
  9])
```

如果你刚开始接触NumPy，可能会对此感到惊讶，由于NumPy的设计目的是处理大数据，所以你可以想想一下，如果Numpy坚持要将数据复制来复制去的话将会产生何等的性能和内存问题。

如果你想用到的是ndarray切片的一分副本而非视图，就需要明确地进行复制操作，例如`arr[5:8].copy()`

对于高纬度数组，能做更多的事。在一个二维数组中，各索引位置上的元素不再是标量而是以为数组：
```python
In [72]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

In [73]: arr2d[2]
Out[73]: array([7, 8, 9])
```

因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取各个元素。也就是说，下面两种方式是等价的：
```python
In [74]: arr2d[0][2]
Out[74]: 3

In [75]: arr2d[0, 2]
Out[75]: 3
```

在多维数组中，如果省略了后面的索引，则返回的对象是一个唯独低一点的ndarray（它含有高一级唯独上的所有数据）。因此，在2x2x3数组arr3中：

```python
In [76]: arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

In [77]: arr3d
Out[77]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],
       [[ 7,  8,  9],
        [10, 11, 12]]])
```

arr3[0]是一个2x3数组：
```python
In [78]: arr3d[0]
Out[78]: 
array([[1, 2, 3],
       [4, 5, 6]])
```
标量和数组都可以被复制给arr3[0]:
```python
In [79]: old_values = arr3d[0].copy()

In [80]: arr3d[0] = 42

In [81]: arr3d
Out[81]: 
array([[[42, 42, 42],
        [42, 42, 42]],
       [[ 7,  8,  9],
        [10, 11, 12]]])

In [82]: arr3d[0] = old_values

In [83]: arr3d
Out[83]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],
       [[ 7,  8,  9],
        [10, 11, 12]]])
```
相似的，arr3[1,0]可以访问索引为(1,0)开头的那些值
```python
In [84]: arr3d[1, 0]
Out[84]: array([7, 8, 9])
```

### 切片索引

ndarray的切片语法跟python列表这样的一维对象差不多：
```python
In [88]: arr
Out[88]: array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])

In [89]: arr[1:6]
Out[89]: array([ 1,  2,  3,  4, 64])
```
对于之前的二维数组arr2d，其切片方式稍显不同
```python
In [90]: arr2d
Out[90]: 
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [91]: arr2d[:2]
Out[91]: 
array([[1, 2, 3],
       [4, 5, 6]])
```

你可以一次传入多个切片，就像传入多个索引那样：
```python
In [92]: arr2d[:2, 1:]
Out[92]: 
array([[2, 3],
       [5, 6]])
```

这样进行切片时，只能得到相同位维数的数组视图。通过将整数索引和切片混合，可以得到低纬度的切片。

```python
In [93]: arr2d[1, :2]
Out[93]: array([4, 5])
```

自然，对切片表达式的赋值操作也会被扩散到整个选区：

```python
In [96]: arr2d[:2, 1:] = 0

In [97]: arr2d
Out[97]: 
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])
```

### 布尔型索引